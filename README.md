# STM32TimerArray
To aid the user with hardware based programmable timers, this library provides a timer array implementation for the STM32 platform.

## Environment
The project is intended for PlatformIO+STM32Cube environments, with C++ language.

## Versions
### Released
- Version 0.2.0\
  Interrupt safe version, but only lightly tested.\
  Probably suitable for becoming V1.0.0

- Version 0.1.0\
  Basic functionality exists.

### Next planned version (V1.0.0)
V0.2.0 with testing of functionality and proof of interrupt safety. Some simple out of the box working examples would be a nice addition.

Don't hold your breath for this version though, use V0.2.0. If any problem is encountered, please open an issue, or write an email.

# Usage (V0.2.0)
### -1. Compile a mixed C/C++ project
First of all you have to understand, that the STM32 HAL environment uses C code, while this library requires C++. To use both of them an easy way is to create a  your_app.h your_app.cpp pair and copy these codes to them.

```
// in file: your_app.h
#ifndef _YOUR_APP_H_
#define _YOUR_APP_H_

void your_app();

#endif // _YOUR_APP_H_
```

```
// in file: your_app.cpp
extern "C" {
#include "your_app.h"
}

void your_app(){
    // implementation here
}
```

```
// in file: main.c (generated by CubeMX)
#include "your_app.h"
...
int main(){
    ...
    // after everything is configured
    your_app();

    // infinite loop to catch returning from your app
    while(1);
}
...
```

### 0. Basics of the library
The library works with two classes, the `TimerArrayControl` handling the hardware and `Timer` instances holding timed callbacks. A `Timer` holds the amount of ticks until the callback is fired. It can be attached to a `TimerArrayControl`, counting from that moment the callback will be fired after the specified amount of ticks elapsed in the controller. The user can set the controller's counting frequency to match the needs.

### 1. Setup a controller
To initialize the `TimerArrayControl` you have to decide which hardware timer you want to use. Be aware, that some timers don't have capture compare registers which this library relies on.

When you found a suitable timer, create a `TIM_HandleTypeDef` instance representing it by hand or by using the CubeMX code generator.

```
// in file: your_app.cpp
#include "STM32TimerArray.hpp"

// tim hardware handle
TIM_HandleTypeDef htimx;

// timer hardware's input frequency, set in code or CubeMX
// in this example we use the CPU's frequency
// (what was also set in CubeMX)
uint32_t timerInputFrequency = F_CPU;

// The timers targeted frequency division,
// might not be achievable with the available hardware.
// Divides the |timerInputFrequency|,
// the result is the controller's tick frequency.
// To get a 1 kHz tick frequency, we divided the
// input frequency with the target frequency.
// Warning: this is integer division, the result
// will be rounded towards negative infinity.
uint32_t frequencyDivision = timerInputFrequency/1000;

// Number of usable bits for counting in the timer.
// Some timers have 16 bits, others have 32 bit
// counter register.
// Using 16 bits for a 32 bit counter will be OK,
// but severly limits the maximum possible delay.
uint32_t timerCounterBits = 16;

// instantiate the controller
TimerArrayControl timerControl(
    &htimx,
    timerInputFrequency,
    frequencyDivision,
    timerCounterBits);
```

### 2. Creating a one shot timer
To fire callbacks, besides the controller we need a callback function and a `Timer` object. Callback functions don't have arguments or a return value and they are called on the interrupt thread.

```
// callback function (assumes NUCLEO-F303RE board)
// reference to the user LED may change depending
// on the used hardware
void toggle_led(){
    HAL_GPIO_TogglePin(LD2_PORT, LD2_PIN);
}

Timer t_toggle(
    1000,      // the number of ticks to wait
    false,     // isPeriodic, false means one shot
    toggle_led // pointer to the callback function
);

void example1(){
    // turn off LED to be sure
    HAL_GPIO_WritePin(LD2_PORT, LD2_PIN, GPIO_PIN_RESET);
    
    // attach before begin is valid too
    // timerControl.attachTimer(&t_toggle);

    // start timer array configured in the previous
    // section to run at 1 kHz (tick frequency)
    timerControl.begin();

    // initiate one second delay
    // 1 ms (millisecond) per tick counting
    // multiplied by 1000 ticks is 1000 ms or 1 sec
    timerControl.attachTimer(&t_toggle);
    
    // wait here forever (except when a callback is fired)
    while(1);
}
```

### 3. Creating a periodic timer
Creating a periodic timer is as easy as setting the isPeriodic flag true when `t_toggle` is instantiated in the previous example. This one modification will result in a blinking LED, changing state every second.

### 4. Changing the delay of a timer, without changing when it was started
The motivation for this functionality is to have a timing sequence, with the delay changing possibly in every iteration without losing the time of the attach. This is not trivially achievable just by attaching a new timer in the callback function, the timer's hardware keeps counting during interrupts too. To factor this out, the controllers `changeTimerDelay` function can be used. In the following example we create a 1 Hz PWM signal with 100 ms pulses on the LED, using `timerControl` and `t_toggle` from the previous example. The timing of the callbacks should be as accurate as using a timer natively to generate the callbacks. (But not as good as hardware PWM generation!)

```
...
// callback for t_toggle
uint16_t ticks = 100;
void toggle_led(){
    // change LED state
    HAL_GPIO_TogglePin(LD2_PORT, LD2_PIN);

    // choose next timeout
    ticks = ticks == 100 ? 900 : 100;

    // update the timer's delay
    timerControl.changeTimerDelay(&t_toggle, ticks);
}

...

void example2(){
    // turn on LED
    HAL_GPIO_WritePin(LD2_PORT, LD2_PIN, GPIO_PIN_SET);

    // add the only timer needed
    timerControl.attachTimer(&t_toggle);

    // set the first timeout to 100 ms
    timerControl.changeTimerDelay(&t_toggle, ticks);

    // start timer array at 1 kHz tick frequency
    timerControl.begin();
    
    // wait here forever (except when a callback is fired)
    while(1);
}
```

# Next steps
- Add unit testing (without hardware)
- Add integration testing (with specific hardware)
- Add ready to run examples, with CubeMX setup
  instructions\
  or pure HAL config functions and project setup
  instructions